// TUI Music Player Example - Music player UI mockup
// Showcases: Tabs, Table, Gauge, Block, Layout

import "std/tui/style.zc"
import "std/tui/text.zc"
import "std/tui/terminal.zc"
import "std/tui/buffer.zc"
import "std/tui/layout.zc"
import "std/tui/event.zc"
import "std/tui/widget.zc"
import "std/tui/widgets/block.zc"
import "std/tui/widgets/tabs.zc"
import "std/tui/widgets/table.zc"
import "std/tui/widgets/gauge.zc"
import "std/tui/widgets/paragraph.zc"
import "std/tui/widgets/sparkline.zc"

include <stdlib.h>
include <string.h>
include <stdio.h>

// Global state
let g_tab_index = 0;
let g_table_state: TableState;
let g_playing = false;
let g_progress = 0;       // 0-100
let g_tick_count = 0;
let g_current_track = 0;
let g_volume = 75;

// Tab titles
let g_tab_titles: char*[3];

// Track data
def NUM_TRACKS = 8;
let g_track_titles: char*[8];
let g_track_artists: char*[8];
let g_track_albums: char*[8];
let g_track_durations: char*[8];

// EQ visualization data
let g_eq_data: int[32];

fn init_state() {
    g_table_state = TableState::new();
    g_tab_titles[0] = "Library";
    g_tab_titles[1] = "Playlist";
    g_tab_titles[2] = "Equalizer";

    g_track_titles[0] = "Bohemian Rhapsody";
    g_track_titles[1] = "Stairway to Heaven";
    g_track_titles[2] = "Hotel California";
    g_track_titles[3] = "Comfortably Numb";
    g_track_titles[4] = "Wish You Were Here";
    g_track_titles[5] = "Imagine";
    g_track_titles[6] = "Let It Be";
    g_track_titles[7] = "Hey Jude";

    g_track_artists[0] = "Queen";
    g_track_artists[1] = "Led Zeppelin";
    g_track_artists[2] = "Eagles";
    g_track_artists[3] = "Pink Floyd";
    g_track_artists[4] = "Pink Floyd";
    g_track_artists[5] = "John Lennon";
    g_track_artists[6] = "The Beatles";
    g_track_artists[7] = "The Beatles";

    g_track_albums[0] = "A Night at the Opera";
    g_track_albums[1] = "Led Zeppelin IV";
    g_track_albums[2] = "Hotel California";
    g_track_albums[3] = "The Wall";
    g_track_albums[4] = "Wish You Were Here";
    g_track_albums[5] = "Imagine";
    g_track_albums[6] = "Let It Be";
    g_track_albums[7] = "Hey Jude";

    g_track_durations[0] = "5:55";
    g_track_durations[1] = "8:02";
    g_track_durations[2] = "6:30";
    g_track_durations[3] = "6:23";
    g_track_durations[4] = "5:34";
    g_track_durations[5] = "3:07";
    g_track_durations[6] = "4:03";
    g_track_durations[7] = "7:11";

    let i = 0;
    while (i < 32) {
        g_eq_data[i] = 30 + (i * 7 + 13) % 70;
        i = i + 1;
    }
}

fn update() {
    g_tick_count = g_tick_count + 1;

    if (g_playing) {
        g_progress = g_progress + 1;
        if (g_progress > 100) {
            g_progress = 0;
            g_current_track = (g_current_track + 1) % NUM_TRACKS;
            g_table_state.selected = g_current_track;
        }
    }

    // Animate EQ bars
    let i = 0;
    while (i < 32) {
        g_eq_data[i] = 10 + (g_tick_count * (i + 3) * 7 + i * 13) % 90;
        i = i + 1;
    }
}

fn draw(f: Frame*) {
    let area = f.size();

    // Main layout: tabs + content + player controls
    let main_constraints: Constraint[3];
    main_constraints[0] = Constraint::length(3);
    main_constraints[1] = Constraint::min(5);
    main_constraints[2] = Constraint::length(5);
    let main_layout = Layout::vertical().set_constraints(main_constraints, 3);
    let main_rects = main_layout.split(area);

    // Tab bar
    let tabs = Tabs::new(g_tab_titles, 3)
        .set_selected(g_tab_index)
        .set_block(Block::bordered().set_title("Zen Player").set_border_style(Style::fg(Color::magenta())))
        .set_highlight_style(Style::fg(Color::magenta()).add_modifier(MOD_BOLD));
    tabs.render(main_rects[0], f.buffer);

    // Content area based on selected tab
    if (g_tab_index == 0 || g_tab_index == 1) {
        draw_track_list(f, main_rects[1]);
    } else {
        draw_equalizer(f, main_rects[1]);
    }

    // Player controls at bottom
    draw_controls(f, main_rects[2]);

    free(main_rects);
}

fn draw_track_list(f: Frame*, area: Rect) {
    let header_cells: char*[4];
    header_cells[0] = "#";
    header_cells[1] = "Title";
    header_cells[2] = "Artist";
    header_cells[3] = "Duration";
    let header = Row::new(header_cells, 4)
        .set_style(Style::fg(Color::cyan()).add_modifier(MOD_BOLD));

    // Static track number strings to avoid 2D array and dangling pointers
    let g_track_nums: char*[8];
    g_track_nums[0] = "1";
    g_track_nums[1] = "2";
    g_track_nums[2] = "3";
    g_track_nums[3] = "4";
    g_track_nums[4] = "5";
    g_track_nums[5] = "6";
    g_track_nums[6] = "7";
    g_track_nums[7] = "8";

    // Declare all cells arrays at function scope so Row pointers remain valid
    let c0: char*[4]; let c1: char*[4]; let c2: char*[4]; let c3: char*[4];
    let c4: char*[4]; let c5: char*[4]; let c6: char*[4]; let c7: char*[4];
    let all_cells: char**[8];
    all_cells[0] = (char**)c0; all_cells[1] = (char**)c1; all_cells[2] = (char**)c2; all_cells[3] = (char**)c3;
    all_cells[4] = (char**)c4; all_cells[5] = (char**)c5; all_cells[6] = (char**)c6; all_cells[7] = (char**)c7;

    let rows: Row[8];
    let i = 0;
    while (i < NUM_TRACKS) {
        let cells = all_cells[i];
        cells[0] = g_track_nums[i];
        cells[1] = g_track_titles[i];
        cells[2] = g_track_artists[i];
        cells[3] = g_track_durations[i];

        let style = Style::new();
        if (i == g_current_track && g_playing) {
            style = Style::fg(Color::green());
        }
        rows[i] = Row::new(cells, 4).set_style(style);
        i = i + 1;
    }

    let col_widths: int[4];
    col_widths[0] = 4;
    col_widths[1] = 25;
    col_widths[2] = 20;
    col_widths[3] = 8;

    let title = "Library";
    if (g_tab_index == 1) title = "Playlist";

    let table = Table::new(rows, NUM_TRACKS)
        .set_header(header)
        .set_widths(col_widths, 4)
        .set_block(Block::bordered().set_title(title).set_border_type(BORDER_ROUNDED))
        .set_highlight_style(Style::fg(Color::black()).set_bg(Color::magenta()));
    table.render_stateful(area, f.buffer, &g_table_state);
}

fn draw_equalizer(f: Frame*, area: Rect) {
    let spark = Sparkline::new(g_eq_data, 32)
        .set_max(100)
        .set_block(Block::bordered().set_title("Equalizer").set_border_type(BORDER_ROUNDED))
        .set_style(Style::fg(Color::magenta()));
    spark.render(area, f.buffer);
}

fn draw_controls(f: Frame*, area: Rect) {
    // Split: now playing info + progress bar + controls
    let ctrl_constraints: Constraint[3];
    ctrl_constraints[0] = Constraint::length(1);
    ctrl_constraints[1] = Constraint::length(3);
    ctrl_constraints[2] = Constraint::length(1);
    let ctrl_layout = Layout::vertical().set_constraints(ctrl_constraints, 3);
    let ctrl_rects = ctrl_layout.split(area);

    // Now playing line
    let now_playing: char[128];
    if (g_playing) {
        sprintf(now_playing, " Playing: %s - %s", g_track_titles[g_current_track], g_track_artists[g_current_track]);
    } else {
        sprintf(now_playing, " Paused: %s - %s", g_track_titles[g_current_track], g_track_artists[g_current_track]);
    }
    let np_style = Style::fg(Color::white()).add_modifier(MOD_BOLD);
    f.set_string(ctrl_rects[0].x, ctrl_rects[0].y, now_playing, np_style);

    // Progress bar
    let gauge = Gauge::new()
        .set_percent(g_progress)
        .set_block(Block::bordered().set_border_style(Style::fg(Color::magenta())))
        .set_gauge_style(Style::fg(Color::magenta()));
    gauge.render(ctrl_rects[1], f.buffer);

    // Controls line
    let play_char = "||";
    if (!g_playing) play_char = "> ";

    let ctrl_text: char[128];
    sprintf(ctrl_text, " %s  |  << Prev  |  Next >>  |  Vol: %d%%  |  q: Quit  Space: Play/Pause  n/p: Next/Prev", play_char, g_volume);
    let ctrl_style = Style::fg(Color::white()).set_bg(Color::blue());
    let cx = ctrl_rects[2].x;
    let ci: usize = 0;
    while (ctrl_text[ci] != 0 && cx < ctrl_rects[2].x + ctrl_rects[2].width) {
        f.set_char(cx, ctrl_rects[2].y, ctrl_text[ci], ctrl_style);
        cx = cx + 1;
        ci = ci + 1;
    }
    while (cx < ctrl_rects[2].x + ctrl_rects[2].width) {
        f.set_char(cx, ctrl_rects[2].y, ' ', ctrl_style);
        cx = cx + 1;
    }

    free(ctrl_rects);
}

fn handle_event(evt: Event) -> int {
    if (evt.kind != EVT_KEY) {
        update();
        return 1;
    }

    if (evt.key.code == KEY_CHAR && evt.key.ch == 'q') return 0;

    if (evt.key.code == KEY_CHAR && evt.key.ch == ' ') {
        g_playing = !g_playing;
    }

    if (evt.key.code == KEY_CHAR && evt.key.ch == 'n') {
        g_current_track = (g_current_track + 1) % NUM_TRACKS;
        g_table_state.selected = g_current_track;
        g_progress = 0;
    }

    if (evt.key.code == KEY_CHAR && evt.key.ch == 'p') {
        g_current_track = g_current_track - 1;
        if (g_current_track < 0) g_current_track = NUM_TRACKS - 1;
        g_table_state.selected = g_current_track;
        g_progress = 0;
    }

    if (evt.key.code == KEY_TAB) {
        g_tab_index = (g_tab_index + 1) % 3;
    }

    if (evt.key.code == KEY_DOWN) {
        g_table_state.next(NUM_TRACKS);
    }
    if (evt.key.code == KEY_UP) {
        g_table_state.previous(NUM_TRACKS);
    }
    if (evt.key.code == KEY_ENTER) {
        g_current_track = g_table_state.selected;
        g_progress = 0;
        g_playing = true;
    }

    if (evt.key.code == KEY_CHAR && evt.key.ch == '+') {
        g_volume = g_volume + 5;
        if (g_volume > 100) g_volume = 100;
    }
    if (evt.key.code == KEY_CHAR && evt.key.ch == '-') {
        g_volume = g_volume - 5;
        if (g_volume < 0) g_volume = 0;
    }

    update();
    return 1;
}

fn main() {
    init_state();
    let draw_fn = fn(f: Frame*) { draw(f); };
    let event_fn = fn(e: Event) -> int { return handle_event(e); };
    tui_run(draw_fn, event_fn);
}
