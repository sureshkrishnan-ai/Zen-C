// TUI Dashboard Example - System-monitor-style dashboard
// Showcases: Tabs, Sparkline, Gauge, BarChart, Table, List, Block, Layout

import "std/tui/style.zc"
import "std/tui/text.zc"
import "std/tui/terminal.zc"
import "std/tui/buffer.zc"
import "std/tui/layout.zc"
import "std/tui/event.zc"
import "std/tui/widget.zc"
import "std/tui/widgets/block.zc"
import "std/tui/widgets/tabs.zc"
import "std/tui/widgets/sparkline.zc"
import "std/tui/widgets/gauge.zc"
import "std/tui/widgets/barchart.zc"
import "std/tui/widgets/table.zc"
import "std/tui/widgets/list.zc"
import "std/tui/widgets/paragraph.zc"

include <stdlib.h>
include <string.h>
include <stdio.h>

// Global application state
let g_tab_index = 0;
let g_list_state: ListState;
let g_table_state: TableState;
let g_tick_count = 0;

// Simulated CPU data (sparkline)
let g_cpu_data: int[60];
let g_cpu_idx = 0;

// Tab titles
let g_tab_titles: char*[3];

fn init_state() {
    g_list_state = ListState::new();
    g_table_state = TableState::new();
    g_tab_titles[0] = "Overview";
    g_tab_titles[1] = "Processes";
    g_tab_titles[2] = "Logs";

    let i = 0;
    while (i < 60) {
        g_cpu_data[i] = 0;
        i = i + 1;
    }
}

fn update_data() {
    g_tick_count = g_tick_count + 1;

    // Simple pseudo-random CPU usage simulation
    let val = (g_tick_count * 7 + 13) % 100;
    g_cpu_data[g_cpu_idx] = val;
    g_cpu_idx = (g_cpu_idx + 1) % 60;
}

fn draw(f: Frame*) {
    let area = f.size();

    // Main layout: top bar + content + status bar
    let main_constraints: Constraint[3];
    main_constraints[0] = Constraint::length(3);
    main_constraints[1] = Constraint::min(5);
    main_constraints[2] = Constraint::length(1);
    let main_layout = Layout::vertical().set_constraints(main_constraints, 3);
    let main_rects = main_layout.split(area);

    // Tab bar
    let tabs = Tabs::new(g_tab_titles, 3)
        .set_selected(g_tab_index)
        .set_block(Block::bordered().set_title("Dashboard"))
        .set_highlight_style(Style::fg(Color::cyan()).add_modifier(MOD_BOLD));
    tabs.render(main_rects[0], f.buffer);

    if (g_tab_index == 0) {
        draw_overview(f, main_rects[1]);
    } else if (g_tab_index == 1) {
        draw_processes(f, main_rects[1]);
    } else {
        draw_logs(f, main_rects[1]);
    }

    // Status bar
    let status_style = Style::fg(Color::white()).set_bg(Color::blue());
    let status_text = "q: Quit | Tab: Switch | Up/Down: Navigate";
    f.set_string(main_rects[2].x, main_rects[2].y, status_text, status_style);
    // Fill rest of status bar
    let sx = main_rects[2].x + (int)strlen(status_text);
    while (sx < main_rects[2].x + main_rects[2].width) {
        f.set_char(sx, main_rects[2].y, ' ', status_style);
        sx = sx + 1;
    }

    free(main_rects);
}

fn draw_overview(f: Frame*, area: Rect) {
    // Split into left and right panels
    let h_constraints: Constraint[2];
    h_constraints[0] = Constraint::percentage(50);
    h_constraints[1] = Constraint::percentage(50);
    let h_layout = Layout::horizontal().set_constraints(h_constraints, 2);
    let h_rects = h_layout.split(area);

    // Left panel: Sparkline + Gauge + BarChart
    let left_constraints: Constraint[3];
    left_constraints[0] = Constraint::percentage(40);
    left_constraints[1] = Constraint::length(3);
    left_constraints[2] = Constraint::min(5);
    let left_layout = Layout::vertical().set_constraints(left_constraints, 3);
    let left_rects = left_layout.split(h_rects[0]);

    // CPU Sparkline
    let ordered_data: int[60];
    let di = 0;
    while (di < 60) {
        ordered_data[di] = g_cpu_data[(g_cpu_idx + di) % 60];
        di = di + 1;
    }
    let spark = Sparkline::new(ordered_data, 60)
        .set_max(100)
        .set_block(Block::bordered().set_title("CPU Usage"))
        .set_style(Style::fg(Color::cyan()));
    spark.render(left_rects[0], f.buffer);

    // Memory Gauge
    let mem_pct = (g_tick_count * 3 + 45) % 100;
    let gauge = Gauge::new()
        .set_percent(mem_pct)
        .set_block(Block::bordered().set_title("Memory"))
        .set_gauge_style(Style::fg(Color::magenta()));
    gauge.render(left_rects[1], f.buffer);

    // Disk BarChart
    let disk_data: BarGroup[4];
    disk_data[0] = BarGroup { label: "/", value: 65 };
    disk_data[1] = BarGroup { label: "/home", value: 45 };
    disk_data[2] = BarGroup { label: "/tmp", value: 20 };
    disk_data[3] = BarGroup { label: "/var", value: 80 };
    let barchart = BarChart::new(disk_data, 4)
        .set_bar_width(5)
        .set_bar_gap(2)
        .set_bar_style(Style::fg(Color::yellow()))
        .set_block(Block::bordered().set_title("Disk Usage %"));
    barchart.render(left_rects[2], f.buffer);

    // Right panel: Info paragraph
    let info_text = Text::raw("System Dashboard\n\nThis is a TUI demo built with Zen-C.\nIt showcases the Ratatui-like widget library.\n\nSwitch tabs with Tab key.\nNavigate lists with Up/Down.\nPress q to quit.");
    let para = Paragraph::new(info_text)
        .set_block(Block::bordered().set_title("Info").set_border_type(BORDER_ROUNDED))
        .set_wrap(true);
    para.render(h_rects[1], f.buffer);

    free(left_rects);
    free(h_rects);
}

fn draw_processes(f: Frame*, area: Rect) {
    // Process table
    let header_cells: char*[4];
    header_cells[0] = "PID";
    header_cells[1] = "Name";
    header_cells[2] = "CPU%";
    header_cells[3] = "Mem%";
    let header = Row::new(header_cells, 4);

    let rows: Row[6];
    let r0: char*[4]; r0[0] = "1"; r0[1] = "init"; r0[2] = "0.1"; r0[3] = "0.5";
    let r1: char*[4]; r1[0] = "234"; r1[1] = "firefox"; r1[2] = "12.3"; r1[3] = "8.2";
    let r2: char*[4]; r2[0] = "567"; r2[1] = "code"; r2[2] = "8.7"; r2[3] = "5.1";
    let r3: char*[4]; r3[0] = "890"; r3[1] = "terminal"; r3[2] = "2.1"; r3[3] = "1.3";
    let r4: char*[4]; r4[0] = "1234"; r4[1] = "docker"; r4[2] = "4.5"; r4[3] = "3.8";
    let r5: char*[4]; r5[0] = "5678"; r5[1] = "node"; r5[2] = "6.2"; r5[3] = "4.1";
    rows[0] = Row::new(r0, 4);
    rows[1] = Row::new(r1, 4);
    rows[2] = Row::new(r2, 4);
    rows[3] = Row::new(r3, 4);
    rows[4] = Row::new(r4, 4);
    rows[5] = Row::new(r5, 4);

    let col_widths: int[4];
    col_widths[0] = 8;
    col_widths[1] = 15;
    col_widths[2] = 8;
    col_widths[3] = 8;

    let table = Table::new(rows, 6)
        .set_header(header)
        .set_widths(col_widths, 4)
        .set_block(Block::bordered().set_title("Processes"))
        .set_highlight_style(Style::fg(Color::black()).set_bg(Color::cyan()));
    table.render_stateful(area, f.buffer, &g_table_state);
}

fn draw_logs(f: Frame*, area: Rect) {
    let items: ListItem[8];
    items[0] = ListItem::new("[INFO]  System started");
    items[1] = ListItem::styled("[WARN]  High memory usage detected", Style::fg(Color::yellow()));
    items[2] = ListItem::new("[INFO]  Network interface eth0 up");
    items[3] = ListItem::styled("[ERROR] Disk /dev/sda1 nearly full", Style::fg(Color::red()));
    items[4] = ListItem::new("[INFO]  User session started");
    items[5] = ListItem::new("[INFO]  Backup completed");
    items[6] = ListItem::styled("[WARN]  CPU temperature high", Style::fg(Color::yellow()));
    items[7] = ListItem::new("[INFO]  Cron job finished");

    let list = List::new(items, 8)
        .set_block(Block::bordered().set_title("System Logs").set_border_type(BORDER_ROUNDED))
        .set_highlight_style(Style::fg(Color::black()).set_bg(Color::green()))
        .set_highlight_symbol(">> ");
    list.render_stateful(area, f.buffer, &g_list_state);
}

fn handle_event(evt: Event) -> int {
    if (evt.kind == EVT_KEY) {
        if (evt.key.code == KEY_CHAR && evt.key.ch == 'q') return 0;

        if (evt.key.code == KEY_TAB) {
            g_tab_index = (g_tab_index + 1) % 3;
        }

        if (evt.key.code == KEY_DOWN) {
            if (g_tab_index == 1) {
                g_table_state.next(6);
            } else if (g_tab_index == 2) {
                g_list_state.next(8);
            }
        }
        if (evt.key.code == KEY_UP) {
            if (g_tab_index == 1) {
                g_table_state.previous(6);
            } else if (g_tab_index == 2) {
                g_list_state.previous(8);
            }
        }
    }

    update_data();
    return 1;
}

fn main() {
    init_state();
    update_data();
    let draw_fn = fn(f: Frame*) { draw(f); };
    let event_fn = fn(e: Event) -> int { return handle_event(e); };
    tui_run(draw_fn, event_fn);
}
