// TUI File Browser Example - Two-pane file browser
// Showcases: List, Paragraph, Input, Block, Layout

import "std/tui/style.zc"
import "std/tui/text.zc"
import "std/tui/terminal.zc"
import "std/tui/buffer.zc"
import "std/tui/layout.zc"
import "std/tui/event.zc"
import "std/tui/widget.zc"
import "std/tui/widgets/block.zc"
import "std/tui/widgets/list.zc"
import "std/tui/widgets/paragraph.zc"
import "std/tui/widgets/input.zc"

include <stdlib.h>
include <string.h>
include <stdio.h>
include <dirent.h>
include <sys/stat.h>
include <unistd.h>

struct FBEntry {
    name: char[256];
    is_dir: int;
}

// Raw block for directory reading
raw {
    int _fb_read_dir(const char* path, FBEntry* entries, int max_entries) {
        DIR* d = opendir(path);
        if (!d) return 0;

        int count = 0;
        struct dirent* ent;
        while ((ent = readdir(d)) != NULL && count < max_entries) {
            if (strcmp(ent->d_name, ".") == 0) continue;
            strncpy(entries[count].name, ent->d_name, 255);
            entries[count].name[255] = 0;
            entries[count].is_dir = (ent->d_type == DT_DIR);
            count++;
        }
        closedir(d);
        return count;
    }

    int _fb_read_file(const char* path, char* buf, int max_len) {
        FILE* f = fopen(path, "r");
        if (!f) return 0;
        int n = fread(buf, 1, max_len - 1, f);
        buf[n] = 0;
        fclose(f);
        return n;
    }

    void _fb_getcwd(char* buf, int size) {
        getcwd(buf, size);
    }
}

extern fn _fb_read_dir(path: const char*, entries: FBEntry*, max_entries: int) -> int;
extern fn _fb_read_file(path: const char*, buf: char*, max_len: int) -> int;
extern fn _fb_getcwd(buf: char*, size: int);

// Global state
def MAX_ENTRIES = 256;
let g_entries: FBEntry[256];
let g_entry_count = 0;
let g_list_state: ListState;
let g_current_path: char[1024];
let g_preview_buf: char[4096];
let g_preview_len = 0;
let g_input: Input;
let g_input_active = false;

fn load_directory(path: char*) {
    g_entry_count = _fb_read_dir(path, g_entries, MAX_ENTRIES);
    g_list_state = ListState::new();
    g_preview_buf[0] = 0;
    g_preview_len = 0;
    strcpy(g_current_path, path);
}

fn load_preview() {
    if (g_entry_count == 0) return;
    let idx = g_list_state.selected;
    if (idx < 0 || idx >= g_entry_count) return;

    let entry = &g_entries[idx];
    if (entry.is_dir) {
        strcpy(g_preview_buf, "[Directory]");
        g_preview_len = (int)strlen(g_preview_buf);
        return;
    }

    // Build full path
    let fullpath: char[2048];
    sprintf(fullpath, "%s/%s", g_current_path, entry.name);

    g_preview_len = _fb_read_file(fullpath, g_preview_buf, 4096);
    if (g_preview_len == 0) {
        strcpy(g_preview_buf, "[Cannot read file]");
        g_preview_len = (int)strlen(g_preview_buf);
    }
}

fn enter_directory() {
    if (g_entry_count == 0) return;
    let idx = g_list_state.selected;
    if (idx < 0 || idx >= g_entry_count) return;

    let entry = &g_entries[idx];
    if (!entry.is_dir) return;

    if (strcmp(entry.name, "..") == 0) {
        // Go up one directory
        let len = (int)strlen(g_current_path);
        let i = len - 1;
        while (i > 0 && g_current_path[i] != '/') {
            i = i - 1;
        }
        if (i == 0) {
            g_current_path[0] = '/';
            g_current_path[1] = 0;
        } else {
            g_current_path[i] = 0;
        }
    } else {
        let new_path: char[2048];
        if (g_current_path[strlen(g_current_path) - 1] == '/') {
            sprintf(new_path, "%s%s", g_current_path, entry.name);
        } else {
            sprintf(new_path, "%s/%s", g_current_path, entry.name);
        }
        strcpy(g_current_path, new_path);
    }

    load_directory(g_current_path);
    load_preview();
}

fn draw(f: Frame*) {
    let area = f.size();

    // Main layout: path bar + content + input bar
    let main_constraints: Constraint[3];
    main_constraints[0] = Constraint::length(3);
    main_constraints[1] = Constraint::min(5);
    main_constraints[2] = Constraint::length(3);
    let main_layout = Layout::vertical().set_constraints(main_constraints, 3);
    let main_rects = main_layout.split(area);

    // Path display
    let path_text = Text::raw(g_current_path);
    let path_para = Paragraph::new(path_text)
        .set_block(Block::bordered().set_title("Path").set_border_style(Style::fg(Color::cyan())));
    path_para.render(main_rects[0], f.buffer);

    // Content: left file list + right preview
    let h_constraints: Constraint[2];
    h_constraints[0] = Constraint::percentage(40);
    h_constraints[1] = Constraint::percentage(60);
    let h_layout = Layout::horizontal().set_constraints(h_constraints, 2);
    let h_rects = h_layout.split(main_rects[1]);

    // File list
    let items: ListItem[256];
    let i = 0;
    while (i < g_entry_count && i < MAX_ENTRIES) {
        let style = Style::new();
        if (g_entries[i].is_dir) {
            style = Style::fg(Color::blue()).add_modifier(MOD_BOLD);
        }
        items[i] = ListItem::styled(g_entries[i].name, style);
        i = i + 1;
    }

    let list = List::new(items, g_entry_count)
        .set_block(Block::bordered().set_title("Files").set_border_type(BORDER_ROUNDED))
        .set_highlight_style(Style::fg(Color::black()).set_bg(Color::cyan()))
        .set_highlight_symbol("> ");
    list.render_stateful(h_rects[0], f.buffer, &g_list_state);

    // Preview
    let preview_title: char[256];
    if (g_entry_count > 0 && g_list_state.selected < g_entry_count) {
        sprintf(preview_title, "Preview: %s", g_entries[g_list_state.selected].name);
    } else {
        strcpy(preview_title, "Preview");
    }

    let preview_text = Text::raw(g_preview_buf);
    let preview = Paragraph::new(preview_text)
        .set_block(Block::bordered().set_title(preview_title).set_border_type(BORDER_ROUNDED))
        .set_wrap(true);
    preview.render(h_rects[1], f.buffer);

    // Input bar
    let input_block = Block::bordered().set_title("Go to path (press /)");
    if (g_input_active) {
        input_block = input_block.set_border_style(Style::fg(Color::yellow()));
    }
    g_input.has_block = true;
    g_input.block = input_block;
    g_input.render(main_rects[2], f.buffer);

    free(h_rects);
    free(main_rects);
}

fn handle_event(evt: Event) -> int {
    if (evt.kind != EVT_KEY) return 1;

    if (g_input_active) {
        if (evt.key.code == KEY_ESC) {
            g_input_active = false;
            return 1;
        }
        if (evt.key.code == KEY_ENTER) {
            g_input_active = false;
            let path = g_input.value();
            if (strlen(path) > 0) {
                load_directory(path);
                load_preview();
            }
            return 1;
        }
        g_input.handle_key(evt.key);
        return 1;
    }

    if (evt.key.code == KEY_CHAR && evt.key.ch == 'q') return 0;

    if (evt.key.code == KEY_CHAR && evt.key.ch == '/') {
        g_input_active = true;
        g_input.clear();
        g_input.set_text(g_current_path);
        return 1;
    }

    if (evt.key.code == KEY_DOWN) {
        g_list_state.next(g_entry_count);
        load_preview();
    }
    if (evt.key.code == KEY_UP) {
        g_list_state.previous(g_entry_count);
        load_preview();
    }
    if (evt.key.code == KEY_ENTER) {
        enter_directory();
    }

    return 1;
}

fn main() {
    g_input = Input::new();
    _fb_getcwd(g_current_path, 1024);
    load_directory(g_current_path);
    load_preview();
    let draw_fn = fn(f: Frame*) { draw(f); };
    let event_fn = fn(e: Event) -> int { return handle_event(e); };
    tui_run(draw_fn, event_fn);
}
