// Zen-C Cloud Build - Dockerfile Generation Implementation

#include "docker.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

// Use real malloc for cloud module
#undef malloc
#undef free
#undef realloc
#undef calloc

int docker_is_available(void) {
    int ret = system("docker --version > /dev/null 2>&1");
    return ret == 0;
}

// Check if base image is Alpine (uses busybox adduser/addgroup)
static int is_alpine_based(const char *image) {
    if (!image) return 1;  // Default to alpine-style
    return strstr(image, "alpine") != NULL;
}

// Write user creation command appropriate for the base image
static void write_user_creation(FILE *f, const char *base_image, const char *user) {
    if (!user || strcmp(user, "root") == 0) return;

    fprintf(f, "# Create non-root user\n");
    if (is_alpine_based(base_image)) {
        // Alpine uses BusyBox addgroup/adduser
        fprintf(f, "RUN addgroup -S %s && adduser -S %s -G %s\n\n", user, user, user);
    } else {
        // Debian/Ubuntu/RHEL use shadow-utils
        fprintf(f, "RUN groupadd -r %s && useradd -r -g %s %s\n\n", user, user, user);
    }
}

int docker_generate_dockerfile(CloudConfig *cfg, const char *binary_name,
                               const char *output_dir) {
    if (!cfg || !binary_name) return 0;

    // Create output directory if needed
    char dockerfile_path[512];
    snprintf(dockerfile_path, sizeof(dockerfile_path), "%s/Dockerfile",
             output_dir ? output_dir : ".");

    FILE *f = fopen(dockerfile_path, "w");
    if (!f) {
        fprintf(stderr, "[cloud] Error: Cannot create Dockerfile at %s\n", dockerfile_path);
        return 0;
    }

    // Header comment
    fprintf(f, "# Dockerfile generated by Zen-C Cloud Build\n");
    fprintf(f, "# Project: %s v%s\n\n",
            cfg->name ? cfg->name : binary_name,
            cfg->version ? cfg->version : "0.1.0");

    if (cfg->multi_stage) {
        // Multi-stage build: copy pre-built binary
        fprintf(f, "# Build stage - binary is pre-built by Zen-C compiler\n");
        fprintf(f, "FROM %s AS builder\n", cfg->builder_image ? cfg->builder_image : "alpine:3.19");
        fprintf(f, "WORKDIR /build\n");
        fprintf(f, "COPY %s .\n", binary_name);
        fprintf(f, "RUN chmod +x %s\n\n", binary_name);

        // Runtime stage
        fprintf(f, "# Runtime stage\n");
        fprintf(f, "FROM %s\n", cfg->base_image ? cfg->base_image : "alpine:3.19");
        fprintf(f, "\n");

        // Create non-root user
        write_user_creation(f, cfg->base_image, cfg->user);

        // Working directory
        fprintf(f, "WORKDIR %s\n", cfg->workdir ? cfg->workdir : "/app");
        fprintf(f, "\n");

        // Copy binary from builder stage
        fprintf(f, "# Copy binary from builder\n");
        fprintf(f, "COPY --from=builder /build/%s .\n", binary_name);

        // Set ownership
        if (cfg->user && strcmp(cfg->user, "root") != 0) {
            fprintf(f, "RUN chown -R %s:%s %s\n",
                    cfg->user, cfg->user, cfg->workdir ? cfg->workdir : "/app");
        }
        fprintf(f, "\n");

    } else {
        // Simple single-stage build
        fprintf(f, "FROM %s\n", cfg->base_image ? cfg->base_image : "alpine:3.19");
        fprintf(f, "\n");

        // Create non-root user
        write_user_creation(f, cfg->base_image, cfg->user);

        // Working directory
        fprintf(f, "WORKDIR %s\n\n", cfg->workdir ? cfg->workdir : "/app");

        // Copy binary
        fprintf(f, "COPY %s .\n", binary_name);
        fprintf(f, "RUN chmod +x %s\n", binary_name);

        if (cfg->user && strcmp(cfg->user, "root") != 0) {
            fprintf(f, "RUN chown -R %s:%s %s\n",
                    cfg->user, cfg->user, cfg->workdir ? cfg->workdir : "/app");
        }
        fprintf(f, "\n");
    }

    // Switch to non-root user
    if (cfg->user && strcmp(cfg->user, "root") != 0) {
        fprintf(f, "USER %s\n\n", cfg->user);
    }

    // Expose ports
    if (cfg->expose_count > 0) {
        fprintf(f, "# Expose ports\n");
        for (int i = 0; i < cfg->expose_count; i++) {
            fprintf(f, "EXPOSE %d\n", cfg->expose_ports[i]);
        }
        fprintf(f, "\n");
    }

    // Environment variables
    if (cfg->env_count > 0) {
        fprintf(f, "# Environment variables\n");
        for (int i = 0; i < cfg->env_count; i++) {
            fprintf(f, "ENV %s\n", cfg->env_vars[i]);
        }
        fprintf(f, "\n");
    }

    // Health check
    if (cfg->healthcheck_cmd && strlen(cfg->healthcheck_cmd) > 0) {
        fprintf(f, "# Health check\n");
        fprintf(f, "HEALTHCHECK --interval=%ds --timeout=%ds --retries=%d \\\n",
                cfg->healthcheck_interval,
                cfg->healthcheck_timeout,
                cfg->healthcheck_retries);
        fprintf(f, "    CMD %s || exit 1\n\n", cfg->healthcheck_cmd);
    }

    // Entrypoint
    fprintf(f, "# Start application\n");
    if (cfg->entrypoint && strlen(cfg->entrypoint) > 0) {
        fprintf(f, "ENTRYPOINT %s\n", cfg->entrypoint);
    } else {
        fprintf(f, "ENTRYPOINT [\"./%s\"]\n", binary_name);
    }

    fclose(f);
    printf("[cloud] Generated Dockerfile at %s\n", dockerfile_path);
    return 1;
}

int docker_build_image(CloudConfig *cfg, const char *context_dir, int verbose) {
    if (!cfg) return 0;

    if (!docker_is_available()) {
        fprintf(stderr, "[cloud] Error: Docker is not available\n");
        return 0;
    }

    char *image_name = cloud_config_image_name(cfg);
    if (!image_name) {
        fprintf(stderr, "[cloud] Error: Could not determine image name\n");
        return 0;
    }

    char cmd[2048];
    snprintf(cmd, sizeof(cmd), "docker build -t %s %s %s",
             image_name,
             verbose ? "" : "-q",
             context_dir ? context_dir : ".");

    printf("[cloud] Building Docker image: %s\n", image_name);
    if (verbose) {
        printf("[cloud] Running: %s\n", cmd);
    }

    int ret = system(cmd);
    free(image_name);

    if (ret != 0) {
        fprintf(stderr, "[cloud] Error: Docker build failed\n");
        return 0;
    }

    printf("[cloud] Docker image built successfully\n");
    return 1;
}

int docker_push_image(CloudConfig *cfg, int verbose) {
    if (!cfg) return 0;

    if (!docker_is_available()) {
        fprintf(stderr, "[cloud] Error: Docker is not available\n");
        return 0;
    }

    if (!cfg->registry_url || strlen(cfg->registry_url) == 0) {
        fprintf(stderr, "[cloud] Error: No registry URL specified. Use --registry=<url>\n");
        return 0;
    }

    char *image_name = cloud_config_image_name(cfg);
    if (!image_name) {
        fprintf(stderr, "[cloud] Error: Could not determine image name\n");
        return 0;
    }

    char cmd[2048];
    snprintf(cmd, sizeof(cmd), "docker push %s", image_name);

    printf("[cloud] Pushing Docker image: %s\n", image_name);
    if (verbose) {
        printf("[cloud] Running: %s\n", cmd);
    }

    int ret = system(cmd);
    free(image_name);

    if (ret != 0) {
        fprintf(stderr, "[cloud] Error: Docker push failed\n");
        return 0;
    }

    printf("[cloud] Docker image pushed successfully\n");
    return 1;
}
