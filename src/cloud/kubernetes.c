// Zen-C Cloud Build - Kubernetes Manifest Generation Implementation

#include "kubernetes.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>

// Use real malloc for cloud module
#undef malloc
#undef free
#undef realloc
#undef calloc

int k8s_is_available(void) {
    int ret = system("kubectl version --client > /dev/null 2>&1");
    return ret == 0;
}

static int ensure_directory(const char *path) {
    struct stat st = {0};
    if (stat(path, &st) == -1) {
        #ifdef _WIN32
        return mkdir(path) == 0;
        #else
        return mkdir(path, 0755) == 0;
        #endif
    }
    return 1;
}

static int generate_deployment(CloudConfig *cfg, const char *output_dir) {
    char filepath[512];
    snprintf(filepath, sizeof(filepath), "%s/deployment.yaml", output_dir);

    FILE *f = fopen(filepath, "w");
    if (!f) {
        fprintf(stderr, "[cloud] Error: Cannot create %s\n", filepath);
        return 0;
    }

    char *image_name = cloud_config_image_name(cfg);

    // Deployment header
    fprintf(f, "# Kubernetes Deployment generated by Zen-C Cloud Build\n");
    fprintf(f, "apiVersion: apps/v1\n");
    fprintf(f, "kind: Deployment\n");
    fprintf(f, "metadata:\n");
    fprintf(f, "  name: %s\n", cfg->name);
    fprintf(f, "  namespace: %s\n", cfg->namespace ? cfg->namespace : "default");
    fprintf(f, "  labels:\n");
    fprintf(f, "    app: %s\n", cfg->name);

    // Additional labels
    for (int i = 0; i < cfg->label_count; i++) {
        fprintf(f, "    %s\n", cfg->labels[i]);
    }

    // Spec
    fprintf(f, "spec:\n");
    fprintf(f, "  replicas: %d\n", cfg->replicas);
    fprintf(f, "  selector:\n");
    fprintf(f, "    matchLabels:\n");
    fprintf(f, "      app: %s\n", cfg->name);

    // Template
    fprintf(f, "  template:\n");
    fprintf(f, "    metadata:\n");
    fprintf(f, "      labels:\n");
    fprintf(f, "        app: %s\n", cfg->name);

    fprintf(f, "    spec:\n");
    fprintf(f, "      containers:\n");
    fprintf(f, "      - name: %s\n", cfg->name);
    fprintf(f, "        image: %s\n", image_name);
    // Use IfNotPresent for local images, Always if registry is set
    if (cfg->registry_url && strlen(cfg->registry_url) > 0) {
        fprintf(f, "        imagePullPolicy: Always\n");
    } else {
        fprintf(f, "        imagePullPolicy: IfNotPresent\n");
    }

    // Ports
    if (cfg->target_port > 0) {
        fprintf(f, "        ports:\n");
        fprintf(f, "        - containerPort: %d\n", cfg->target_port);
        fprintf(f, "          protocol: TCP\n");
    }

    // Resources
    fprintf(f, "        resources:\n");
    fprintf(f, "          requests:\n");
    fprintf(f, "            cpu: \"%s\"\n", cfg->cpu_request ? cfg->cpu_request : "100m");
    fprintf(f, "            memory: \"%s\"\n", cfg->memory_request ? cfg->memory_request : "128Mi");
    fprintf(f, "          limits:\n");
    fprintf(f, "            cpu: \"%s\"\n", cfg->cpu_limit ? cfg->cpu_limit : "500m");
    fprintf(f, "            memory: \"%s\"\n", cfg->memory_limit ? cfg->memory_limit : "512Mi");

    // Environment from ConfigMaps
    if (cfg->configmap_count > 0 || cfg->secret_count > 0) {
        fprintf(f, "        envFrom:\n");
        for (int i = 0; i < cfg->configmap_count; i++) {
            fprintf(f, "        - configMapRef:\n");
            fprintf(f, "            name: %s\n", cfg->configmaps[i]);
        }
        for (int i = 0; i < cfg->secret_count; i++) {
            fprintf(f, "        - secretRef:\n");
            fprintf(f, "            name: %s\n", cfg->secrets[i]);
        }
    }

    // Liveness probe
    if (cfg->liveness_path && cfg->liveness_port > 0) {
        fprintf(f, "        livenessProbe:\n");
        fprintf(f, "          httpGet:\n");
        fprintf(f, "            path: %s\n", cfg->liveness_path);
        fprintf(f, "            port: %d\n", cfg->liveness_port);
        fprintf(f, "          initialDelaySeconds: 10\n");
        fprintf(f, "          periodSeconds: 30\n");
    }

    // Readiness probe
    if (cfg->readiness_path && cfg->readiness_port > 0) {
        fprintf(f, "        readinessProbe:\n");
        fprintf(f, "          httpGet:\n");
        fprintf(f, "            path: %s\n", cfg->readiness_path);
        fprintf(f, "            port: %d\n", cfg->readiness_port);
        fprintf(f, "          initialDelaySeconds: 5\n");
        fprintf(f, "          periodSeconds: 10\n");
    }

    free(image_name);
    fclose(f);
    printf("[cloud] Generated %s\n", filepath);
    return 1;
}

static int generate_service(CloudConfig *cfg, const char *output_dir) {
    char filepath[512];
    snprintf(filepath, sizeof(filepath), "%s/service.yaml", output_dir);

    FILE *f = fopen(filepath, "w");
    if (!f) {
        fprintf(stderr, "[cloud] Error: Cannot create %s\n", filepath);
        return 0;
    }

    // Service header
    fprintf(f, "# Kubernetes Service generated by Zen-C Cloud Build\n");
    fprintf(f, "apiVersion: v1\n");
    fprintf(f, "kind: Service\n");
    fprintf(f, "metadata:\n");
    fprintf(f, "  name: %s\n", cfg->name);
    fprintf(f, "  namespace: %s\n", cfg->namespace ? cfg->namespace : "default");
    fprintf(f, "  labels:\n");
    fprintf(f, "    app: %s\n", cfg->name);

    // Spec
    fprintf(f, "spec:\n");
    fprintf(f, "  type: %s\n", cfg->service_type ? cfg->service_type : "ClusterIP");
    fprintf(f, "  selector:\n");
    fprintf(f, "    app: %s\n", cfg->name);
    fprintf(f, "  ports:\n");
    fprintf(f, "  - port: %d\n", cfg->service_port > 0 ? cfg->service_port : 80);
    fprintf(f, "    targetPort: %d\n", cfg->target_port > 0 ? cfg->target_port : 8080);
    fprintf(f, "    protocol: TCP\n");
    fprintf(f, "    name: http\n");

    fclose(f);
    printf("[cloud] Generated %s\n", filepath);
    return 1;
}

static int generate_kustomization(CloudConfig *cfg, const char *output_dir) {
    char filepath[512];
    snprintf(filepath, sizeof(filepath), "%s/kustomization.yaml", output_dir);

    FILE *f = fopen(filepath, "w");
    if (!f) {
        fprintf(stderr, "[cloud] Error: Cannot create %s\n", filepath);
        return 0;
    }

    fprintf(f, "# Kustomization generated by Zen-C Cloud Build\n");
    fprintf(f, "apiVersion: kustomize.config.k8s.io/v1beta1\n");
    fprintf(f, "kind: Kustomization\n");
    fprintf(f, "\n");
    fprintf(f, "namespace: %s\n", cfg->namespace ? cfg->namespace : "default");
    fprintf(f, "\n");
    fprintf(f, "commonLabels:\n");
    fprintf(f, "  app: %s\n", cfg->name);
    fprintf(f, "\n");
    fprintf(f, "resources:\n");
    fprintf(f, "  - deployment.yaml\n");
    fprintf(f, "  - service.yaml\n");

    fclose(f);
    printf("[cloud] Generated %s\n", filepath);
    return 1;
}

int k8s_generate_manifests(CloudConfig *cfg, const char *output_dir) {
    if (!cfg) return 0;

    const char *dir = output_dir ? output_dir : "k8s";

    // Create output directory
    if (!ensure_directory(dir)) {
        fprintf(stderr, "[cloud] Error: Cannot create directory %s\n", dir);
        return 0;
    }

    printf("[cloud] Generating Kubernetes manifests in %s/\n", dir);

    // Generate manifests
    if (!generate_deployment(cfg, dir)) return 0;
    if (!generate_service(cfg, dir)) return 0;

    return 1;
}

int k8s_apply_manifests(const char *manifest_dir, int verbose) {
    if (!k8s_is_available()) {
        fprintf(stderr, "[cloud] Error: kubectl is not available\n");
        return 0;
    }

    const char *dir = manifest_dir ? manifest_dir : "k8s";

    char cmd[1024];
    snprintf(cmd, sizeof(cmd), "kubectl apply -f %s/", dir);

    printf("[cloud] Applying Kubernetes manifests from %s/\n", dir);
    if (verbose) {
        printf("[cloud] Running: %s\n", cmd);
    }

    int ret = system(cmd);
    if (ret != 0) {
        fprintf(stderr, "[cloud] Error: kubectl apply failed\n");
        return 0;
    }

    printf("[cloud] Kubernetes resources applied successfully\n");
    return 1;
}

int k8s_delete_manifests(const char *manifest_dir, int verbose) {
    if (!k8s_is_available()) {
        fprintf(stderr, "[cloud] Error: kubectl is not available\n");
        return 0;
    }

    const char *dir = manifest_dir ? manifest_dir : "k8s";

    char cmd[1024];
    snprintf(cmd, sizeof(cmd), "kubectl delete -f %s/", dir);

    printf("[cloud] Deleting Kubernetes resources from %s/\n", dir);
    if (verbose) {
        printf("[cloud] Running: %s\n", cmd);
    }

    int ret = system(cmd);
    if (ret != 0) {
        fprintf(stderr, "[cloud] Warning: kubectl delete may have failed (resources may not exist)\n");
        return 0;
    }

    printf("[cloud] Kubernetes resources deleted successfully\n");
    return 1;
}
